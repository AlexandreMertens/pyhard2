from __future__ import print_function
import StringIO as _StringIO
import csv as _csv

import sip as _sip
for _type in "QDate QDateTime QString QTextStream QTime QUrl QVariant".split():
    _sip.setapi(_type, 2)

from PyQt4 import QtCore, QtGui
Qt = QtCore.Qt
Slot, Signal = QtCore.pyqtSlot, QtCore.pyqtSignal
import PyQt4.Qwt5 as Qwt

from pyhard2 import pid
import pyhard2.rsc
from pyhard2.gui.delegates import DoubleSpinBoxDelegate


class SingleShotProgram(QtCore.QObject):

    """Program that sends new values at predefined times.

    Note:
        The program has its own timer so that the events will fire
        precisely at the given times.

    Attributes:
        started: The signal is emitted when the program starts.
        finished: The signal is emitted when the program has finished
            executing.
        value: The signal is emitted with the value generated by the
            program.

    Methods:
        interval()
        setInterval(msec)
            This property holds the timeout interval in milliseconds.

    """
    started = Signal()
    finished = Signal()
    value = Signal(object)

    def __init__(self):
        super(SingleShotProgram, self).__init__()
        self._timer = QtCore.QTimer(self)
        self._timer.setSingleShot(True)
        self._timer.timeout.connect(self._shoot)
        self._running = False
        self._profile = None
        self._index = -1
        # methods:
        self.setInterval = self._timer.setInterval
        self.interval = self._timer.interval

    def profile(self):
        """Return the profile."""
        return self._profile

    def setProfile(self, profile):
        """Set the profile to `profile`."""
        self._profile = profile

    def isRunning(self):
        """Returns whether the program is running."""
        return self._running

    @property
    def _dt(self):
        """Difference between the current time and the next time."""
        return self._profile.x(self._index + 1) - self._profile.x(self._index)

    @property
    def _dv(self):
        """Difference between the current value and the next value."""
        return self._profile.y(self._index + 1) - self._profile.y(self._index)

    @Slot()
    def start(self):
        """Start or restart the program."""
        if self._running:
            # restart
            self.stop()
        self._running = True
        self.started.emit()
        self._shoot()

    @Slot()
    def stop(self):
        """Stop the program."""
        if not self._running:
            # ignore
            return
        self._running = False
        self._timer.stop()
        self._index = -1
        self.finished.emit()

    @Slot()
    def _shoot(self):
        """Emit a value if it exists or terminate the program."""
        self._index += 1
        try:
            self.value.emit(self._profile.y(self._index))
        except IndexError:
            # Current value does not exist.
            self.stop()
        try:
            # relative time
            dt = self._dt
        except IndexError:
            # Next value does not exist.
            self.stop()
        else:
            self._timer.start(1000 * dt)  # msec


class SetpointRampProgram(SingleShotProgram):

    """Program that performs setpoint ramps."""

    def __init__(self):
        super(SetpointRampProgram, self).__init__()
        self._ramp = None
        self._timer.setSingleShot(False)
        self.started.connect(self._timer.start)
        self.finished.connect(self._timer.stop)

    def setProfile(self, profile):
        """Set the profile to `profile`."""
        super(SetpointRampProgram, self).setProfile(profile)
        self._ramp = pid.Profile(list(self._profile)).ramp()

    @Slot()
    def _shoot(self):
        """Emit a new value if it exists or terminate the program."""
        try:
            self.value.emit(self._ramp.next())
        except StopIteration:
            try:
                self.value.emit(self._profile.y(-1))
            except IndexError:
                # Ignore error: we are stopping anyway.
                pass
            self.stop()


class ProfileData(Qwt.QwtData):

    """Custom `QwtData` handling a QStandardItemModel with two columns
    as `x, y` values.

    Parameters:
        rootItem (QStandardItem): The root item of the model.

    """
    X, Y = range(2)

    def __init__(self, rootItem):
        super(ProfileData, self).__init__()
        self._rootItem = rootItem
        self._model = self._rootItem.model()

    def __iter__(self):
        """Iterate on the model."""
        return (self.sample(i) for i in range(self.size()))

    def _sample(self, i):
        """Return `x,y` values at `i`.

        Raises:
            ValueError: if the the data does not convert to float.

        """
        def _convert(row, column):
            return float(self._rootItem.child(row, column).text())
        try:
            return [_convert(i, j) for j in range(self._model.columnCount())]
        except AttributeError:
            raise ValueError

    def copy(self):
        """Return self."""
        return self

    def size(self):
        """Return the number of rows under `rootItem`.

        Note:
            Rows where values cannot be converted to `float` are not
            counted.

        """
        size = 0
        for row in range(self._model.rowCount(self._rootItem.index())):
            try:
                self._sample(row)
            except ValueError:
                # Up to invalid data
                return size
            else:
                size += 1
        # Model full of valid data
        return size

    def sample(self, i):
        """Return `x,y` values at `i`.

        Raises:
            IndexError: if `i` is invalid.
            ValueError: if the data at `i` do not convert to float.

        """
        if i < 0:
            i += self.size()
        if not 0 <= i < self.size():
            raise IndexError("%s index out of range" % self.__class__.__name__)
        return self._sample(i)

    def x(self, i):
        """Return `x` value at `i`.

        See also:
            `sample()` for the exceptions.
        """
        return self.sample(i)[ProfileData.X]

    def y(self, i):
        """Return `y` value at `i`.

        See also:
            `sample()` for the exceptions.
        """
        return self.sample(i)[ProfileData.Y]


class ItemSelectionModel(QtGui.QItemSelectionModel):

    """QItemSelectionModel with copy/paste and a part of the
    QTableWidget interface.

    """
    def __init__(self, model, parent=None):
        super(ItemSelectionModel, self).__init__(model, parent)

    def currentRow(self):
        """Return the row of the current item."""
        return self.currentIndex().row()

    def currentColumn(self):
        """Return the column of the current item."""
        return self.currentIndex().column()

    def _parentItem(self):
        """Return the parent of the current item."""
        item = self.model().itemFromIndex(self.currentIndex()).parent()
        return item if item else self.model().invisibleRootItem()

    def insertRow(self):
        """Insert an empty row into the table at the current row."""
        parent = self._parentItem()
        parent.insertRow(
            self.currentRow(),
            [QtGui.QStandardItem() for __ in range(parent.columnCount())])

    def insertColumn(self):
        """Insert an empty column into the table at the current column."""
        parent = self._parentItem()
        parent.insertColumn(
            self.currentColumn(),
            [QtGui.QStandardItem() for __ in range(parent.rowCount())])

    def removeRows(self):
        """Remove the selected rows."""
        currentIndex = self.currentIndex()
        selection = self.selectedRows()
        if not selection:
            selection = [currentIndex]
        parent = self._parentItem()
        rowCount = parent.rowCount()
        for row in (index.row() for index in selection):
            parent.removeRow(row)
        parent.setRowCount(rowCount)

    def removeColumns(self):
        """Remove the selected columns."""
        currentIndex = self.currentIndex()
        selection = self.selectedColumns()
        if not selection:
            selection = [currentIndex]
        parent = self._parentItem()
        columnCount = parent.columnCount()
        for column in (index.column() for index in selection):
            parent.removeColumn(column)
        parent.setColumnCount(columnCount)

    def copy(self):
        """Copy the values in the selection to the clipboard."""
        previous = QtCore.QModelIndex()
        fields = []
        for index in sorted(self.selectedIndexes()):
            if index.row() is previous.row():
                fields[-1].append(index.data())
            else:
                fields.append([index.data()])
            previous = index
        csvfile = _StringIO.StringIO()
        writer = _csv.writer(csvfile)
        writer.writerows(fields)
        QtGui.QApplication.clipboard().setText(csvfile.getvalue())

    def paste(self):
        """Paste values in the clipboard at the current item.

        Raises:
            IndexError: if the data in the clipboard does not fit in the
                model.

        """
        currentIndex = self.currentIndex()
        parent = self._parentItem()
        csvfile = _StringIO.StringIO(QtGui.QApplication.clipboard().text())
        try:
            dialect = _csv.Sniffer().sniff(csvfile.read(1024))
        except _csv.Error:
            return
        csvfile.seek(0)
        reader = _csv.reader(csvfile, dialect)
        for i, line in enumerate(reader):
            if currentIndex.column() + len(line) > parent.columnCount():
                raise IndexError
            for j, text in enumerate(line):
                parent.setChild(currentIndex.row() + i,
                                currentIndex.column() + j,
                                QtGui.QStandardItem(text))


class ProgramWidgetUi(QtGui.QWidget):

    def __init__(self, parent=None):
        super(ProgramWidgetUi, self).__init__(parent)
        sp = QtGui.QSizePolicy
        self.verticalLayout = QtGui.QVBoxLayout(self)
        self.setSizePolicy(sp.Fixed, sp.Expanding)
        self.updateGeometry()
        self.toolBar = QtGui.QToolBar(self)
        self.verticalLayout.addWidget(self.toolBar)
        self.programView = QtGui.QTableView(self)
        sizePolicy = QtGui.QSizePolicy(sp.Expanding, sp.Expanding)
        sizePolicy.setVerticalStretch(3)
        self.programView.setSizePolicy(sizePolicy)
        self.programView.setContextMenuPolicy(Qt.ActionsContextMenu)
        self.programView.horizontalHeader().setResizeMode(
            QtGui.QHeaderView.Stretch)
        self.programView.verticalHeader().setVisible(False)
        self.programView.verticalHeader().setDefaultSectionSize(20)
        self.programView.horizontalHeader().setResizeMode(
            0, QtGui.QHeaderView.ResizeToContents)
        self.verticalLayout.addWidget(self.programView)
        self.previewPlot = Qwt.QwtPlot(self)
        sizePolicy = QtGui.QSizePolicy(sp.Expanding, sp.Expanding)
        sizePolicy.setVerticalStretch(2)
        self.previewPlot.setSizePolicy(sizePolicy)
        self.verticalLayout.addWidget(self.previewPlot)


class ProgramWidget(ProgramWidgetUi):

    startRequested = Signal(int)
    stopRequested = Signal(int)

    def __init__(self, parent=None):
        super(ProgramWidget, self).__init__(parent)
        self.driverModel = None
        self.programmableColumn = None
        self._previewPlotItems = []  # defeat GC

        self.model = QtGui.QStandardItemModel(self)
        self.programView.setModel(self.model)

        timeColumnDelegate = DoubleSpinBoxDelegate(parent=self.programView)
        timeColumnDelegate.setRange(0.0, 604800.0)  # 7 days
        self.programView.setItemDelegateForColumn(0, timeColumnDelegate)
        valueColumnDelegate = DoubleSpinBoxDelegate(parent=self.programView)
        self.programView.setItemDelegateForColumn(1, valueColumnDelegate)
        self.programSelectionModel = ItemSelectionModel(self.model,
                                                        self.programView)
        self.programView.setSelectionModel(self.programSelectionModel)

        self.__initActions()

        self.model.dataChanged.connect(lambda topLeft, bottomRight:
                                       self._showPreview())
        self.model.rowsInserted.connect(lambda parent, start, end:
                                        self._showPreview())

    def __initActions(self):

        def icon(name):
            return QtGui.QIcon.fromTheme(
                name, QtGui.QIcon(":/icons/Tango/%s.svg" % name))

        def viewPaste():
            try:
                self.programSelectionModel.paste()
            except IndexError:
                QtGui.QMessageBox.critical(
                    self.programView,  # parent
                    "Invalid clipboard data",  # title
                    "The number of columns in the clipboard is too large.")

        self.copyAction = QtGui.QAction(
            icon("edit-copy"), u"Copy", self,
            shortcut=QtGui.QKeySequence.Copy,
            triggered=self.programSelectionModel.copy)
        self.pasteAction = QtGui.QAction(
            icon("edit-paste"), u"Paste", self,
            shortcut=QtGui.QKeySequence.Paste,
            triggered=viewPaste)
        self.addRowAction = QtGui.QAction(
            icon("list-add"), u"Add row", self,
            triggered=self.programSelectionModel.insertRow)
        self.removeRowAction = QtGui.QAction(
            icon("list-remove"), u"Remove row", self,
            triggered=self.programSelectionModel.removeRows)
        self.startProgramAction = QtGui.QAction(
            icon("media-playback-start"), u"Start program", self,
            triggered=self.startProgram)
        self.stopProgramAction = QtGui.QAction(
            icon("media-playback-stop"), u"Stop program", self,
            triggered=self.stopProgram)
        self.startAllProgramsAction = QtGui.QAction(
            icon("media-seek-forward"), u"Start all programs", self,
            triggered=self.startAllPrograms)
        self.stopAllProgramsAction = QtGui.QAction(
            icon("process-stop"), u"Stop all programs", self,
            triggered=self.stopAllPrograms)

        self.toolBar.addActions((self.startProgramAction,
                                 self.stopProgramAction,
                                 self.startAllProgramsAction,
                                 self.stopAllProgramsAction,
                                 self.copyAction,
                                 self.pasteAction,
                                 self.addRowAction,
                                 self.removeRowAction))
        self.toolBar.insertSeparator(self.copyAction)
        self.toolBar.insertSeparator(self.addRowAction)

        self.programView.addAction(self.copyAction)
        self.programView.addAction(self.pasteAction)
        self.programView.addAction(self.addRowAction)
        self.programView.addAction(self.removeRowAction)

    def _clearPreview(self):
        while self._previewPlotItems:
            self._previewPlotItems.pop().detach()

    def _showPreview(self):
        if not self.driverModel:
            return
        self._clearPreview()
        for row in range(self.model.rowCount()):
            rootItem = self.model.item(row, 0)
            data = ProfileData(rootItem)
            if data.size() > 1:
                label = self.driverModel.verticalHeaderItem(row).text()
                curve = Qwt.QwtPlotCurve(label)
                curve.setData(data)
                curve.attach(self.previewPlot)
                self._previewPlotItems.append(curve)
                marker = Qwt.QwtPlotMarker()
                marker.setLabel(curve.title())
                x, y = (0.5 * (sample(data.size() - 2)
                               + sample(data.size() - 1))
                        for sample in (data.x, data.y))
                marker.setValue(x, y)
                marker.attach(self.previewPlot)
                self._previewPlotItems.append(marker)
        self.previewPlot.replot()

    @property
    def _currentRow(self):
        """Set in `setProgramTableRoot`."""
        rootIndex = self.programView.rootIndex()
        return -1 if not rootIndex.isValid() else rootIndex.row()

    def setDriverModel(self, model):
        self.driverModel = model
        # Make program tree
        self.model.clear()
        self.model.setHorizontalHeaderLabels([u"time /s", u"setpoint"])
        for root in range(model.rowCount()):
            rootItem = QtGui.QStandardItem(
                model.verticalHeaderItem(root).text())
            rootItem.setEditable(False)
            self.model.invisibleRootItem().appendRow(rootItem)
            for row in range(8):
                rootItem.appendRow(
                    [QtGui.QStandardItem(), QtGui.QStandardItem()])

    def setProgramTableRoot(self, row):
        if None in (self.programmableColumn, self.driverModel):
            return
        self.programView.setRootIndex(self.model.index(row, 0))
        if not self.driverModel:
            return
        delegate = self.programView.itemDelegateForColumn(1)
        item = self.driverModel.item(0, self.programmableColumn)
        if item.minimum() is not None:
            delegate.setMinimum(item.minimum())
        if item.maximum() is not None:
            delegate.setMaximum(item.maximum())

    def startProgram(self, row=None):
        """Emit startRequested signal for `row`."""
        if row is None:
            row = self._currentRow
        self.startRequested.emit(row)

    def stopProgram(self, row=None):
        """Emit stopRequested signal for `row`."""
        if row is None:
            row = self._currentRow
        self.stopRequested.emit(row)

    def startAllPrograms(self):
        """Start or restart every program."""
        for row in range(self.model.rowCount()):
            self.startProgram(row)

    def stopAllPrograms(self):
        """Stop every program."""
        for row in range(self.model.rowCount()):
            self.stopProgram(row)


if __name__ == "__main__":
    import sys
    app = QtGui.QApplication(sys.argv)
    app.lastWindowClosed.connect(app.quit)
    widget = ProgramWidget()
    widget.startRequested.connect(lambda row: print("start %i" % row))
    widget.stopRequested.connect(lambda row: print("stop %i" % row))
    root = QtGui.QStandardItem("root")
    root.setEditable(False)
    for row in range(8):
        root.appendRow([QtGui.QStandardItem(), QtGui.QStandardItem()])
    widget.model.invisibleRootItem().appendRow(root)
    widget.programView.setRootIndex(widget.model.index(0, 0))
    widget.show()
    sys.exit(app.exec_())
